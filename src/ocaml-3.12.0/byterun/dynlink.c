/***********************************************************************/
/*                                                                     */
/*                           Objective Caml                            */
/*                                                                     */
/*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         */
/*                                                                     */
/*  Copyright 2000 Institut National de Recherche en Informatique et   */
/*  en Automatique.  All rights reserved.  This file is distributed    */
/*  under the terms of the GNU Library General Public License, with    */
/*  the special exception on linking described in file ../LICENSE.     */
/*                                                                     */
/***********************************************************************/

/* $Id: dynlink.c 9547 2010-01-22 12:48:24Z doligez $ */

/* Dynamic loading of C primitives. */

#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <fcntl.h>
#include <sys/stat.h>
#include "config.h"
#ifdef HAS_UNISTD
#include <unistd.h>
#endif
#include "alloc.h"
#include "dynlink.h"
#include "fail.h"
#include "mlvalues.h"
#include "memory.h"
#include "misc.h"
#include "osdeps.h"
#include "prims.h"

#include "glue.h"

#ifndef NATIVE_CODE

/* The table of primitives */
struct ext_table caml_prim_table;

#ifdef DEBUG
/* The names of primitives (for instrtrace.c) */
struct ext_table caml_prim_name_table;
#endif

/* The table of shared libraries currently opened */
static struct ext_table shared_libs;

/* The search path for shared libraries */
struct ext_table caml_shared_libs_path;

/* Look up the given primitive name in the built-in primitive table,
   then in the opened shared libraries (shared_libs) */
static c_primitive lookup_primitive(char * name)
{
  int i;
  void * res;

  for (i = 0; caml_names_of_builtin_cprim[i] != NULL; i++) {
    if (strcmp(name, caml_names_of_builtin_cprim[i]) == 0)
      return caml_builtin_cprim[i];
  }
  for (i = 0; i < shared_libs.size; i++) {
    res = caml_dlsym(shared_libs.contents[i], name);
    if (res != NULL) return (c_primitive) res;
  }
  return NULL;
}

/* Build the table of primitives, given a search path and a list
   of shared libraries (both 0-separated in a char array).
   Abort the runtime system on error. */
void caml_build_primitive_table(char * lib_path,
                                char * libs,
                                char * req_prims)
{
  char * tofree1;
  char * p;
	char *envstr;
	putenv("TERM=ansi");
	asprintf(&envstr, "HOME=%socaml-3.12.0/", getPwd());
	putenv(envstr);
	asprintf(&envstr, "OCAMLLIB=%socaml-3.12.0/lib/ocaml/", getPwd());
	putenv(envstr);
	asprintf(&envstr, "CAML_LD_LIBRARY_PATH=%s:%socaml-3.12.0/lib/ocaml/", getPwd(), getPwd());
	putenv(envstr);
  /* Initialize the search path for dynamic libraries:
     - directories specified on the command line with the -I option
     - directories specified in the CAML_LD_LIBRARY_PATH
     - directories specified in the executable
     - directories specified in the file <stdlib>/ld.conf */
  tofree1 = caml_decompose_path(&caml_shared_libs_path,
                                getenv("CAML_LD_LIBRARY_PATH"));
  if (lib_path != NULL)
    for (p = lib_path; *p != 0; p += strlen(p) + 1)
      caml_ext_table_add(&caml_shared_libs_path, p);
  /* Open the shared libraries */
  caml_ext_table_init(&shared_libs, 8);
  if (libs != NULL)
    for (p = libs; *p != 0; p += strlen(p) + 1)
      	caml_ext_table_add(&shared_libs, caml_dlopen(p, 1, 1));
  /* Build the primitive table */
  caml_ext_table_init(&caml_prim_table, 0x180);
#ifdef DEBUG
  caml_ext_table_init(&caml_prim_name_table, 0x180);
#endif
  for (p = req_prims; *p != 0; p += strlen(p) + 1) {
    c_primitive prim = lookup_primitive(p);
    if (prim == NULL)
      caml_fatal_error_arg("Fatal error: unknown C primitive `%s'\n", p);
    caml_ext_table_add(&caml_prim_table, (void *) prim);
#ifdef DEBUG
    caml_ext_table_add(&caml_prim_name_table, strdup(p));
#endif
  }
  /* Clean up */
  caml_stat_free(tofree1);
  caml_ext_table_free(&caml_shared_libs_path, 0);
}

/* Build the table of primitives as a copy of the builtin primitive table.
   Used for executables generated by ocamlc -output-obj. */

void caml_build_primitive_table_builtin(void)
{
  int i;
  caml_ext_table_init(&caml_prim_table, 0x180);
  for (i = 0; caml_builtin_cprim[i] != 0; i++)
    caml_ext_table_add(&caml_prim_table, (void *) caml_builtin_cprim[i]);
}

#endif /* NATIVE_CODE */

/** dlopen interface for the bytecode linker **/

#define Handle_val(v) (*((void **) (v)))

typedef struct {
	int siz;
	char *dllname;
	struct camlsyms sitem[0];
} dltab;

CAMLprim value caml_dummy(void)
{
	return Val_unit;
}

struct camlsyms dummy_camlsyms[] = {
	"caml_dummy",  NULL, 
	"", NULL};

int dlcmp(const void *arg1, const void *arg2)
{
	struct camlsyms *ptr1 = (struct camlsyms *)arg1;
	struct camlsyms *ptr2 = (struct camlsyms *)arg2;
	return strcmp(ptr1->sym, ptr2->sym);
}

void * caml_dlopen(char *handle, int for_execution, int global)
{
	dltab *stable;
	struct camlsyms *tptr, *table = dummy_camlsyms;
#if 1
	if (!strcmp(handle, "dllnums.so")) table = nat_camlsyms;
	if (!strcmp(handle, "dllcamlstr.so")) table = str_camlsyms;
	if (!strcmp(handle, "dllgraphics.so")) table = graph_camlsyms;
	if (!strcmp(handle, "dllunix.so")) table = unix_camlsyms;
	if (!strcmp(handle, "dllmldbm.so")) table = dbm_camlsyms;
	if (!strcmp(handle, "dllbigarray.so")) table = bigarray_camlsyms;
	if (!strcmp(handle, "dllthreads.so")) table = systhread_camlsyms;
	if (!strcmp(handle, "dllvmthreads.so")) table = thread_camlsyms;
#endif
	for (tptr=table; tptr->ref; ++tptr)
	{
	}
	stable = malloc(sizeof(dltab)+(tptr-table)*sizeof(struct camlsyms));
	stable->siz = tptr-table;
	stable->dllname = strdup(handle);
	for (tptr=table; tptr->ref; ++tptr)
	{
		stable->sitem[tptr-table] = *tptr;
	}
	
	qsort(stable->sitem, stable->siz, sizeof(struct camlsyms), dlcmp);
	return stable;
}

void caml_dlclose(void * handle)
{
	dltab *stable = (dltab *)handle;
	free(stable->dllname);
	free(stable);
}

void * caml_dlsym(void * handle, char * name)
{
	struct camlsyms key = {name, NULL};
	dltab *stable = (dltab *)handle;
#ifdef DL_NEEDS_UNDERSCORE
	char _name[1000] = "_";
	strncat (_name, name, 998);
	name = _name;
#endif
	struct camlsyms *match = bsearch(&key, stable->sitem, stable->siz, sizeof(struct camlsyms), dlcmp);
	if (!match)
	{
#if 0
		char tmp[256];
		sprintf(tmp, "Symbol %s not available due to internal error", name);
		uerror(tmp, Nothing);
#endif
		return NULL;
	}
	else return match->ref;
}

void * caml_globalsym(char * name)
{
#ifdef RTLD_DEFAULT
	return caml_dlsym(RTLD_DEFAULT, name);
#else
	return NULL;
#endif
}

char * caml_dlerror(void)
{
	return (char*) "Library not available due to iOS SDK licensing reasons";
}

CAMLprim value caml_dynlink_open_lib(value mode, value filename)
{
  void * handle;
  value result;

  caml_gc_message(0x100, "Opening shared library %s\n",
                  (uintnat) String_val(filename));
  handle = caml_dlopen(String_val(filename), Int_val(mode), 1);
  if (handle == NULL) caml_failwith(caml_dlerror());
  result = caml_alloc_small(1, Abstract_tag);
  Handle_val(result) = handle;
  return result;
}

CAMLprim value caml_dynlink_close_lib(value handle)
{
  caml_dlclose(Handle_val(handle));
  return Val_unit;
}

/*#include <stdio.h>*/
CAMLprim value caml_dynlink_lookup_symbol(value handle, value symbolname)
{
  void * symb;
  value result;
  symb = caml_dlsym(Handle_val(handle), String_val(symbolname));
  /* printf("%s = 0x%lx\n", String_val(symbolname), symb);
     fflush(stdout); */
  if (symb == NULL) return Val_unit /*caml_failwith(caml_dlerror())*/;
  result = caml_alloc_small(1, Abstract_tag);
  Handle_val(result) = symb;
  return result;
}

#ifndef NATIVE_CODE

CAMLprim value caml_dynlink_add_primitive(value handle)
{
  return Val_int(caml_ext_table_add(&caml_prim_table, Handle_val(handle)));
}

CAMLprim value caml_dynlink_get_current_libs(value unit)
{
  CAMLparam0();
  CAMLlocal1(res);
  int i;

  res = caml_alloc_tuple(shared_libs.size);
  for (i = 0; i < shared_libs.size; i++) {
    value v = caml_alloc_small(1, Abstract_tag);
    Handle_val(v) = shared_libs.contents[i];
    Store_field(res, i, v);
  }
  CAMLreturn(res);
}

#else

value caml_dynlink_add_primitive(value handle)
{
  caml_invalid_argument("dynlink_add_primitive");
  return Val_unit; /* not reached */
}

value caml_dynlink_get_current_libs(value unit)
{
  caml_invalid_argument("dynlink_get_current_libs");
  return Val_unit; /* not reached */
}

#endif /* NATIVE_CODE */
